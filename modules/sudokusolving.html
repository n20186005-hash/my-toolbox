<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Sudoku Solver</title>
    
    <!-- åŸºç¡€ä¿¡æ¯ -->
    <meta name="tool-id" content="sudoku_solver">
    <meta name="category" content="fun">
    <meta name="icon" content="ğŸ§©">
    
    <!-- é»˜è®¤è‹±æ–‡å†…å®¹ -->
    <meta name="title" content="Sudoku Solver">
    <meta name="description" content="Automatically solve your Sudoku puzzles.">
    
    <!-- å¤šè¯­è¨€é…ç½® -->
    <meta name="lang-title-zh-CN" content="æ•°ç‹¬æ±‚è§£å™¨">
    <meta name="lang-description-zh-CN" content="è‡ªåŠ¨è§£å†³æ‚¨çš„æ•°ç‹¬è°œé¢˜ã€‚">
    
    <meta name="lang-title-zh-TW" content="æ•¸ç¨æ±‚è§£å™¨">
    <meta name="lang-description-zh-TW" content="è‡ªå‹•è§£æ±ºæ‚¨çš„æ•¸ç¨è¬é¡Œã€‚">
    
    <meta name="lang-title-ja" content="æ•°ç‹¬ã‚½ãƒ«ãƒãƒ¼">
    <meta name="lang-description-ja" content="æ•°ç‹¬ãƒ‘ã‚ºãƒ«ã‚’è‡ªå‹•çš„ã«è§£ãã¾ã™ã€‚">
    
    <meta name="lang-title-ru" content="Ğ ĞµÑˆĞ°Ñ‚ĞµĞ»ÑŒ ÑÑƒĞ´Ğ¾ĞºÑƒ">
    <meta name="lang-description-ru" content="ĞĞ²Ñ‚Ğ¾Ğ¼Ğ°Ñ‚Ğ¸Ñ‡ĞµÑĞºĞ¾Ğµ Ñ€ĞµÑˆĞµĞ½Ğ¸Ğµ ÑÑƒĞ´Ğ¾ĞºÑƒ.">
    
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body { 
            padding: 20px; 
            background: #f8fafc; 
            font-family: 'Segoe UI', Roboto, sans-serif;
        }
        .tool-module { 
            background: white; 
            padding: 20px; 
            border-radius: 10px; 
            box-shadow: 0 4px 12px rgba(0,0,0,0.08); 
            max-width: 600px; 
            margin: 0 auto; 
            position: relative; 
        }
        .warning { 
            background-color: #fee2e2; 
            border: 1px solid #ef4444; 
            color: #b91c1c; 
            padding: 10px; 
            border-radius: 5px; 
            margin-top: 10px; 
        }
        .sudoku-grid { 
            display: grid; 
            grid-template-columns: repeat(9, 1fr); 
            gap: 1px; 
            background-color: #333; 
            margin: 20px auto; 
            max-width: 360px; 
            padding: 2px;
        }
        .sudoku-cell { 
            width: 40px; 
            height: 40px; 
            border: 0; 
            text-align: center; 
            font-size: 20px; /* ç¨å¾®åŠ å¤§å­—ä½“ */
            font-weight: 500;
            background-color: white; 
            color: #1e293b;
            cursor: pointer;
        }
        .sudoku-cell:focus { 
            outline: 2px solid #fbbf24; /* èšç„¦è¾¹æ¡†æ”¹ä¸ºé‡‘è‰² */
            background-color: #fefce8; /* èšç„¦æ—¶èƒŒæ™¯å˜ä¸ºæ·¡é»„è‰² */
            z-index: 10;
        }
        /* å¢å¼º3x3åŒºå—åˆ†éš” */
        .sudoku-row:nth-child(3n) { 
            border-bottom: 2px solid #333; 
            margin-bottom: 1px;
        }
        .sudoku-cell:nth-child(3n) { 
            border-right: 2px solid #333; 
            margin-right: 1px;
        }
        .sudoku-row { 
            display: flex; 
        }
        /* å·²è§£å†³æ•°å­—çš„æ ·å¼ - æ”¹ä¸ºæ¸…æ–°çš„ç»¿è‰² */
        .solved { 
            background-color: #dcfce7; /* è–„è·ç»¿èƒŒæ™¯ */
            color: #15803d; /* æ·±ç»¿è‰²æ–‡å­— */
            font-weight: 700;
        }
        /* æŒ‰é’®æ ·å¼ä¼˜åŒ– */
        button {
            transition: all 0.2s ease;
        }
    </style>
</head>
<body>

    <div class="tool-module active" 
         data-id="sudoku_solver" 
         data-category="puzzle" 
         data-title="Sudoku Solver" 
         data-icon="ğŸ§©">
        
        <!-- è¯­è¨€é€‰æ‹©å™¨ -->
        <div class="absolute top-4 right-4">
            <select id="sudoku-lang" onchange="SudokuSolver.changeLang()" class="text-xs border border-gray-300 rounded p-1 bg-gray-50 text-gray-600 focus:outline-none">
                <option value="en" selected>English</option>
                <option value="zh-CN">ç®€ä½“ä¸­æ–‡</option>
                <option value="zh-TW">ç¹é«”ä¸­æ–‡</option>
                <option value="ja">æ—¥æœ¬èª</option>
                <option value="ru">Ğ ÑƒÑÑĞºĞ¸Ğ¹</option>
            </select>
        </div>

        <h2 class="text-xl font-bold mb-4 text-gray-800 border-b pb-2" data-i18n="title">ğŸ§© Sudoku Solver</h2>
        
        <div class="text-center mb-4">
            <p data-i18n="instructions" class="text-sm text-gray-600 mb-4">Enter the numbers of your Sudoku puzzle (1-9) and click solve. Empty cells can be left blank.</p>
            
            <div id="sudoku-container"></div>
            
            <div class="flex gap-2 mt-4 justify-center">
                <button onclick="SudokuSolver.solve()" class="bg-green-600 text-white py-2 px-4 rounded font-bold hover:bg-green-700 transition" data-i18n="btn_solve">Solve</button>
                <button onclick="SudokuSolver.clear()" class="bg-gray-600 text-white py-2 px-4 rounded font-bold hover:bg-gray-700 transition" data-i18n="btn_clear">Clear</button>
                <button onclick="SudokuSolver.generateExample()" class="bg-blue-600 text-white py-2 px-4 rounded font-bold hover:bg-blue-700 transition" data-i18n="btn_example">Example</button>
            </div>
            
            <div id="sudoku-message" class="mt-4 font-medium"></div>
        </div>
        
        <div class="warning text-sm mt-4" data-i18n="disclaimer">Disclaimer: This solver works for valid Sudoku puzzles with a unique solution.</div>
    </div>

    <script>
        const SudokuSolver = {
            i18n: {
                'en': {
                    title: 'ğŸ§© Sudoku Solver',
                    instructions: 'Enter the numbers of your Sudoku puzzle (1-9) and click solve. Empty cells can be left blank.',
                    btn_solve: 'Solve',
                    btn_clear: 'Clear',
                    btn_example: 'Example',
                    solving: 'Solving...',
                    solved: 'Sudoku solved!',
                    unsolvable: 'This Sudoku puzzle is unsolvable.',
                    invalid: 'Invalid Sudoku puzzle. Please check your entries.',
                    disclaimer: 'Disclaimer: This solver works for valid Sudoku puzzles with a unique solution.'
                },
                'zh-CN': {
                    title: 'ğŸ§© æ•°ç‹¬æ±‚è§£å™¨',
                    instructions: 'è¾“å…¥æ‚¨çš„æ•°ç‹¬è°œé¢˜æ•°å­—ï¼ˆ1-9ï¼‰å¹¶ç‚¹å‡»æ±‚è§£ã€‚ç©ºç™½å•å…ƒæ ¼å¯ç•™ç©ºã€‚',
                    btn_solve: 'æ±‚è§£',
                    btn_clear: 'æ¸…é™¤',
                    btn_example: 'ç¤ºä¾‹',
                    solving: 'æ­£åœ¨æ±‚è§£...',
                    solved: 'æ•°ç‹¬å·²è§£å†³ï¼',
                    unsolvable: 'è¿™ä¸ªæ•°ç‹¬è°œé¢˜æ— æ³•è§£å†³ã€‚',
                    invalid: 'æ— æ•ˆçš„æ•°ç‹¬è°œé¢˜ã€‚è¯·æ£€æŸ¥æ‚¨çš„è¾“å…¥ã€‚',
                    disclaimer: 'å…è´£å£°æ˜ï¼šæ­¤æ±‚è§£å™¨é€‚ç”¨äºå…·æœ‰å”¯ä¸€è§£çš„æœ‰æ•ˆæ•°ç‹¬è°œé¢˜ã€‚'
                },
                'zh-TW': {
                    title: 'ğŸ§© æ•¸ç¨æ±‚è§£å™¨',
                    instructions: 'è¼¸å…¥æ‚¨çš„æ•¸ç¨è¬é¡Œæ•¸å­—ï¼ˆ1-9ï¼‰ä¸¦é»æ“Šæ±‚è§£ã€‚ç©ºç™½å–®å…ƒæ ¼å¯ç•™ç©ºã€‚',
                    btn_solve: 'æ±‚è§£',
                    btn_clear: 'æ¸…é™¤',
                    btn_example: 'ç¤ºä¾‹',
                    solving: 'æ­£åœ¨æ±‚è§£...',
                    solved: 'æ•¸ç¨å·²è§£æ±ºï¼',
                    unsolvable: 'é€™å€‹æ•¸ç¨è¬é¡Œç„¡æ³•è§£æ±ºã€‚',
                    invalid: 'ç„¡æ•ˆçš„æ•¸ç¨è¬é¡Œã€‚è«‹æª¢æŸ¥æ‚¨çš„è¼¸å…¥ã€‚',
                    disclaimer: 'å…è²¬è²æ˜ï¼šæ­¤æ±‚è§£å™¨é©ç”¨æ–¼å…·æœ‰å”¯ä¸€è§£çš„æœ‰æ•ˆæ•¸ç¨è¬é¡Œã€‚'
                },
                'ja': {
                    title: 'ğŸ§© æ•°ç‹¬ã‚½ãƒ«ãƒãƒ¼',
                    instructions: 'æ•°ç‹¬ãƒ‘ã‚ºãƒ«ã®æ•°å­—ï¼ˆ1-9ï¼‰ã‚’å…¥åŠ›ã—ã€è§£ãã‚’ã‚¯ãƒªãƒƒã‚¯ã—ã¦ãã ã•ã„ã€‚ç©ºã®ã‚»ãƒ«ã¯ãã®ã¾ã¾ã«ã—ã¦ãŠãã“ã¨ãŒã§ãã¾ã™ã€‚',
                    btn_solve: 'è§£ã',
                    btn_clear: 'ã‚¯ãƒªã‚¢',
                    btn_example: 'ä¾‹',
                    solving: 'è§£æ±ºä¸­...',
                    solved: 'æ•°ç‹¬ãŒè§£ã‘ã¾ã—ãŸï¼',
                    unsolvable: 'ã“ã®æ•°ç‹¬ãƒ‘ã‚ºãƒ«ã¯è§£ã‘ã¾ã›ã‚“ã€‚',
                    invalid: 'ç„¡åŠ¹ãªæ•°ç‹¬ãƒ‘ã‚ºãƒ«ã§ã™ã€‚å…¥åŠ›ã‚’ç¢ºèªã—ã¦ãã ã•ã„ã€‚',
                    disclaimer: 'å…è²¬äº‹é …ï¼šã“ã®ã‚½ãƒ«ãƒãƒ¼ã¯ã€ä¸€æ„ã®è§£ã‚’æŒã¤æœ‰åŠ¹ãªæ•°ç‹¬ãƒ‘ã‚ºãƒ«ã§å‹•ä½œã—ã¾ã™ã€‚'
                },
                'ru': {
                    title: 'ğŸ§© Ğ ĞµÑˆĞ°Ñ‚ĞµĞ»ÑŒ ÑÑƒĞ´Ğ¾ĞºÑƒ',
                    instructions: 'Ğ’Ğ²ĞµĞ´Ğ¸Ñ‚Ğµ Ñ‡Ğ¸ÑĞ»Ğ° Ğ²Ğ°ÑˆĞµĞ³Ğ¾ ÑÑƒĞ´Ğ¾ĞºÑƒ (1-9) Ğ¸ Ğ½Ğ°Ğ¶Ğ¼Ğ¸Ñ‚Ğµ "Ğ ĞµÑˆĞ¸Ñ‚ÑŒ". ĞŸÑƒÑÑ‚Ñ‹Ğµ ÑÑ‡ĞµĞ¹ĞºĞ¸ Ğ¼Ğ¾Ğ¶Ğ½Ğ¾ Ğ¾ÑÑ‚Ğ°Ğ²Ğ¸Ñ‚ÑŒ Ğ¿ÑƒÑÑ‚Ñ‹Ğ¼Ğ¸.',
                    btn_solve: 'Ğ ĞµÑˆĞ¸Ñ‚ÑŒ',
                    btn_clear: 'ĞÑ‡Ğ¸ÑÑ‚Ğ¸Ñ‚ÑŒ',
                    btn_example: 'ĞŸÑ€Ğ¸Ğ¼ĞµÑ€',
                    solving: 'Ğ ĞµÑˆĞ°Ñ...',
                    solved: 'Ğ¡ÑƒĞ´Ğ¾ĞºÑƒ Ñ€ĞµÑˆĞµĞ½Ğ¾!',
                    unsolvable: 'Ğ­Ñ‚Ğ¾ ÑÑƒĞ´Ğ¾ĞºÑƒ Ğ½ĞµÑ€Ğ°Ğ·Ñ€ĞµÑˆĞ¸Ğ¼Ğ¾.',
                    invalid: 'ĞĞµĞ²ĞµÑ€Ğ½Ğ¾Ğµ ÑÑƒĞ´Ğ¾ĞºÑƒ. ĞŸÑ€Ğ¾Ğ²ĞµÑ€ÑŒÑ‚Ğµ ÑĞ²Ğ¾Ğ¸ Ğ·Ğ°Ğ¿Ğ¸ÑĞ¸.',
                    disclaimer: 'ĞÑ‚ĞºĞ°Ğ· Ğ¾Ñ‚ Ğ¾Ñ‚Ğ²ĞµÑ‚ÑÑ‚Ğ²ĞµĞ½Ğ½Ğ¾ÑÑ‚Ğ¸: Ğ­Ñ‚Ğ¾Ñ‚ Ñ€ĞµÑˆĞ°Ñ‚ĞµĞ»ÑŒ Ñ€Ğ°Ğ±Ğ¾Ñ‚Ğ°ĞµÑ‚ Ğ´Ğ»Ñ Ğ´ĞµĞ¹ÑÑ‚Ğ²Ğ¸Ñ‚ĞµĞ»ÑŒĞ½Ñ‹Ñ… ÑÑƒĞ´Ğ¾ĞºÑƒ Ñ ÑƒĞ½Ğ¸ĞºĞ°Ğ»ÑŒĞ½Ñ‹Ğ¼ Ñ€ĞµÑˆĞµĞ½Ğ¸ĞµĞ¼.'
                }
            },

            init: () => {
                SudokuSolver.loadLangFromUrl();
                SudokuSolver.createGrid();
            },

            // ä»URLå‚æ•°åŠ è½½è¯­è¨€è®¾ç½®
            loadLangFromUrl: () => {
                const params = new URLSearchParams(window.location.search);
                const lang = params.get('lang');
                const langSelect = document.getElementById('sudoku-lang');
                
                if (lang && SudokuSolver.i18n[lang]) {
                    langSelect.value = lang;
                    SudokuSolver.changeLang(false); // ä¸æ›´æ–°URLå‚æ•°
                }
            },

            // æ›´æ–°URLå‚æ•°
            updateUrlWithLang: (lang) => {
                const params = new URLSearchParams(window.location.search);
                params.set('lang', lang);
                
                // æ›´æ–°URLè€Œä¸åˆ·æ–°é¡µé¢
                window.history.pushState({}, '', `${window.location.pathname}?${params.toString()}`);
            },

            createGrid: () => {
                const container = document.getElementById('sudoku-container');
                container.innerHTML = '';
                
                for (let row = 0; row < 9; row++) {
                    const rowDiv = document.createElement('div');
                    rowDiv.className = 'sudoku-row';
                    
                    for (let col = 0; col < 9; col++) {
                        const input = document.createElement('input');
                        input.type = 'text';
                        input.maxLength = 1;
                        input.className = 'sudoku-cell';
                        input.dataset.row = row;
                        input.dataset.col = col;
                        
                        input.addEventListener('input', (e) => {
                            // åªå…è®¸1-9çš„æ•°å­—
                            e.target.value = e.target.value.replace(/[^1-9]/g, '');
                        });

                        // é”®ç›˜å¯¼èˆªå¢å¼º
                        input.addEventListener('keydown', (e) => {
                            const currentRow = parseInt(e.target.dataset.row);
                            const currentCol = parseInt(e.target.dataset.col);
                            let nextRow = currentRow;
                            let nextCol = currentCol;

                            if (e.key === 'ArrowRight') nextCol++;
                            else if (e.key === 'ArrowLeft') nextCol--;
                            else if (e.key === 'ArrowDown') nextRow++;
                            else if (e.key === 'ArrowUp') nextRow--;
                            else return;

                            e.preventDefault();
                            if (nextRow >= 0 && nextRow < 9 && nextCol >= 0 && nextCol < 9) {
                                const nextInput = document.querySelector(`.sudoku-cell[data-row="${nextRow}"][data-col="${nextCol}"]`);
                                if (nextInput) nextInput.focus();
                            }
                        });
                        
                        rowDiv.appendChild(input);
                    }
                    container.appendChild(rowDiv);
                }
            },

            getGrid: () => {
                const grid = Array(9).fill().map(() => Array(9).fill(0));
                const cells = document.getElementsByClassName('sudoku-cell');
                
                for (let i = 0; i < cells.length; i++) {
                    const row = Math.floor(i / 9);
                    const col = i % 9;
                    const value = cells[i].value.trim();
                    
                    grid[row][col] = value ? parseInt(value, 10) : 0;
                    // æ¸…é™¤ä¹‹å‰çš„è§£å†³æ–¹æ¡ˆæ ‡è®°
                    cells[i].classList.remove('solved');
                }
                
                return grid;
            },

            setGrid: (grid) => {
                const cells = document.getElementsByClassName('sudoku-cell');
                
                for (let i = 0; i < cells.length; i++) {
                    const row = Math.floor(i / 9);
                    const col = i % 9;
                    const originalValue = cells[i].value.trim();
                    
                    if (!originalValue && grid[row][col] !== 0) {
                        cells[i].value = grid[row][col];
                        cells[i].classList.add('solved');
                    }
                }
            },

            clear: () => {
                const cells = document.getElementsByClassName('sudoku-cell');
                for (let cell of cells) {
                    cell.value = '';
                    cell.classList.remove('solved');
                }
                SudokuSolver.showMessage('');
            },

            generateExample: () => {
                SudokuSolver.clear();
                // ç¤ºä¾‹æ•°ç‹¬
                const example = [
                    [5, 3, 0, 0, 7, 0, 0, 0, 0],
                    [6, 0, 0, 1, 9, 5, 0, 0, 0],
                    [0, 9, 8, 0, 0, 0, 0, 6, 0],
                    [8, 0, 0, 0, 6, 0, 0, 0, 3],
                    [4, 0, 0, 8, 0, 3, 0, 0, 1],
                    [7, 0, 0, 0, 2, 0, 0, 0, 6],
                    [0, 6, 0, 0, 0, 0, 2, 8, 0],
                    [0, 0, 0, 4, 1, 9, 0, 0, 5],
                    [0, 0, 0, 0, 8, 0, 0, 7, 9]
                ];
                
                const cells = document.getElementsByClassName('sudoku-cell');
                for (let i = 0; i < cells.length; i++) {
                    const row = Math.floor(i / 9);
                    const col = i % 9;
                    if (example[row][col] !== 0) {
                        cells[i].value = example[row][col];
                    }
                }
            },

            showMessage: (key) => {
                const lang = document.getElementById('sudoku-lang').value;
                const texts = SudokuSolver.i18n[lang];
                const messageEl = document.getElementById('sudoku-message');
                
                messageEl.innerText = key ? texts[key] : '';
                
                // è®¾ç½®æ¶ˆæ¯é¢œè‰²
                if (key === 'solved') messageEl.className = 'mt-4 font-medium text-green-600';
                else if (key === 'unsolvable' || key === 'invalid') messageEl.className = 'mt-4 font-medium text-red-600';
                else if (key === 'solving') messageEl.className = 'mt-4 font-medium text-blue-600';
                else messageEl.className = 'mt-4 font-medium';
            },

            // æ•°ç‹¬æ±‚è§£ç®—æ³•
            solveSudoku: (grid) => {
                const empty = SudokuSolver.findEmptyCell(grid);
                if (!empty) return true; // è§£å†³å®Œæˆ
                
                const [row, col] = empty;
                
                for (let num = 1; num <= 9; num++) {
                    if (SudokuSolver.isValid(grid, num, [row, col])) {
                        grid[row][col] = num;
                        
                        if (SudokuSolver.solveSudoku(grid)) return true;
                        
                        grid[row][col] = 0; // å›æº¯
                    }
                }
                
                return false; // æ— è§£
            },

            findEmptyCell: (grid) => {
                for (let row = 0; row < 9; row++) {
                    for (let col = 0; col < 9; col++) {
                        if (grid[row][col] === 0) {
                            return [row, col];
                        }
                    }
                }
                return null;
            },

            isValid: (grid, num, pos) => {
                // æ£€æŸ¥è¡Œ
                for (let i = 0; i < 9; i++) {
                    if (grid[pos[0]][i] === num && pos[1] !== i) return false;
                }
                
                // æ£€æŸ¥åˆ—
                for (let i = 0; i < 9; i++) {
                    if (grid[i][pos[1]] === num && pos[0] !== i) return false;
                }
                
                // æ£€æŸ¥3x3å­ç½‘æ ¼
                const boxX = Math.floor(pos[1] / 3);
                const boxY = Math.floor(pos[0] / 3);
                
                for (let i = boxY * 3; i < boxY * 3 + 3; i++) {
                    for (let j = boxX * 3; j < boxX * 3 + 3; j++) {
                        if (grid[i][j] === num && (i !== pos[0] || j !== pos[1])) return false;
                    }
                }
                
                return true;
            },

            solve: () => {
                SudokuSolver.showMessage('solving');
                
                // çŸ­æš‚å»¶è¿Ÿä»¥æ˜¾ç¤º"æ­£åœ¨æ±‚è§£"æ¶ˆæ¯
                setTimeout(() => {
                    const grid = SudokuSolver.getGrid();
                    
                    // æ£€æŸ¥åˆå§‹æœ‰æ•ˆæ€§
                    let isValid = true;
                    outerLoop:
                    for (let row = 0; row < 9; row++) {
                        for (let col = 0; col < 9; col++) {
                            if (grid[row][col] !== 0) {
                                const num = grid[row][col];
                                grid[row][col] = 0; // ä¸´æ—¶æ¸…ç©ºä»¥æ£€æŸ¥
                                if (!SudokuSolver.isValid(grid, num, [row, col])) {
                                    isValid = false;
                                    break outerLoop;
                                }
                                grid[row][col] = num; // æ¢å¤
                            }
                        }
                    }
                    
                    if (!isValid) {
                        SudokuSolver.showMessage('invalid');
                        return;
                    }
                    
                    // å°è¯•æ±‚è§£
                    if (SudokuSolver.solveSudoku(grid)) {
                        SudokuSolver.setGrid(grid);
                        SudokuSolver.showMessage('solved');
                    } else {
                        SudokuSolver.showMessage('unsolvable');
                    }
                }, 300);
            },

            // æ·»åŠ updateUrlå‚æ•°æ§åˆ¶æ˜¯å¦æ›´æ–°URL
            changeLang: (updateUrl = true) => {
                const lang = document.getElementById('sudoku-lang').value;
                const texts = SudokuSolver.i18n[lang];
                const elements = document.querySelectorAll('[data-id="sudoku_solver"] [data-i18n]');
                
                elements.forEach(el => {
                    const key = el.getAttribute('data-i18n');
                    if (texts[key]) el.innerText = texts[key];
                });
                
                // å¦‚æœéœ€è¦æ›´æ–°URLï¼Œåˆ™è°ƒç”¨updateUrlWithLangæ–¹æ³•
                if (updateUrl) {
                    SudokuSolver.updateUrlWithLang(lang);
                }
            }
        };

        document.addEventListener('DOMContentLoaded', SudokuSolver.init);
    </script>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            // å…ˆæ£€æŸ¥URLä¸­æ˜¯å¦æœ‰è¯­è¨€å‚æ•°ï¼Œå¦‚æœæœ‰åˆ™ä¸å†è‡ªåŠ¨åŒ¹é…æµè§ˆå™¨è¯­è¨€
            const params = new URLSearchParams(window.location.search);
            if (params.get('lang')) {
                return;
            }
            
            // è‡ªåŠ¨åŒ¹é…æµè§ˆå™¨è¯­è¨€
            const userLang = navigator.language || navigator.userLanguage;
            let targetLang = 'en'; 
            if (userLang.startsWith('zh')) {
                targetLang = userLang.includes('TW') || userLang.includes('HK') ? 'zh-TW' : 'zh-CN';
            } else if (userLang.startsWith('ja')) {
                targetLang = 'ja';
            } else if (userLang.startsWith('ru')) {
                targetLang = 'ru';
            }
            
            if (targetLang !== 'en') {
                const langSelect = document.getElementById('sudoku-lang');
                if(langSelect) {
                    langSelect.value = targetLang;
                    SudokuSolver.changeLang(); // ä¼šæ›´æ–°URLå‚æ•°
                }
            }
        });
    </script>

</body>
</html>
